{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Italic;}
{\colortbl;\red255\green255\blue255;\red244\green0\blue95;\red29\green30\blue26;\red246\green246\blue239;
\red152\green224\blue36;\red157\green101\blue255;\red88\green209\blue235;\red117\green113\blue92;\red250\green132\blue25;
\red224\green213\blue97;}
{\*\expandedcolortbl;;\cssrgb\c97647\c14902\c44706;\cssrgb\c15294\c15686\c13333;\cssrgb\c97255\c97255\c94902;
\cssrgb\c65098\c88627\c18039;\cssrgb\c68235\c50588\c100000;\cssrgb\c40000\c85098\c93725;\cssrgb\c53333\c51765\c43529;\cssrgb\c99216\c59216\c12157;
\cssrgb\c90196\c85882\c45490;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 import\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 math\cf4 \cb1 \ulnone \strokec4 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 numpy\cf4 \ulnone \strokec4  \cf2 \strokec2 as\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \cb1 \ulnone \strokec4 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 collections\cf4 \cb1 \ulnone \strokec4 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 ctypes\cf4 \ulnone \strokec4  \cf2 \strokec2 import\cf4 \strokec4  \cf2 \strokec2 *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  Bio.\cf6 \strokec6 PDB\cf4 \strokec4 .kdtrees \cf2 \strokec2 import\cf4 \strokec4  KDTree\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 pyscf\cf4 \cb1 \ulnone \strokec4 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 chemistry\cf4 \ulnone \strokec4  \cf2 \strokec2 as\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 chem\cf4 \cb1 \ulnone \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f1\i \cf7 \cb3 \strokec7 class
\f0\i0 \cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 readprotein\cf4 \ulnone \strokec4 ():\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     \cf8 \strokec8 # __slots__=['_file']\cf4 \cb1 \strokec4 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf7 \strokec7 __init__\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 file
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._file \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 file
\f0\i0 \cf4 \cb1 \strokec4 \
\cb3         
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._sasa \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 None\cf4 \cb1 \strokec4 \
\cb3         
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._mol_dict \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 None\cf4 \cb1 \strokec4 \
\cb3         
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._secondary \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 None\cf4 \cb1 \strokec4 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 data\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf2 \strokec2 with\cf4 \strokec4  \cf5 \strokec5 open\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._file, \cf10 \strokec10 'r'\cf4 \strokec4 ) \cf2 \strokec2 as\cf4 \strokec4  f:\cb1 \
\cb3             \cf2 \strokec2 yield from\cf4 \strokec4  f\cb1 \
\cb3     \cb1 \
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 numAtoms\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  \cf5 \strokec5 len\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .atoms())\cb1 \
\cb3     \cb1 \
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 getNeighbors\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 atom
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 k
\f0\i0 \cf2 \strokec2 =\cf6 \strokec6 16\cf4 \strokec4 ):\cb1 \
\cb3         allNeighbors \cf2 \strokec2 =\cf4 \strokec4  []\cb1 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .atoms():\cb1 \
\cb3             allNeighbors.\cf5 \strokec5 append\cf4 \strokec4 ((i, 
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 calculateDistance\cf4 \strokec4 (i, 
\f1\i \cf9 \strokec9 atom
\f0\i0 \cf4 \strokec4 )))\cb1 \
\cb3         sorted_list \cf2 \strokec2 =\cf4 \strokec4  \cf5 \strokec5 sorted\cf4 \strokec4 (allNeighbors, 
\f1\i \cf9 \strokec9 key
\f0\i0 \cf2 \strokec2 =
\f1\i \cf7 \strokec7 lambda
\f0\i0 \cf4 \strokec4  
\f1\i \cf9 \strokec9 x
\f0\i0 \cf4 \strokec4 : 
\f1\i \cf9 \strokec9 x
\f0\i0 \cf4 \strokec4 [\cf6 \strokec6 1\cf4 \strokec4 ])\cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  [x \cf2 \strokec2 for\cf4 \strokec4  x \cf2 \strokec2 in\cf4 \strokec4  sorted_list[:
\f1\i \cf9 \strokec9 k
\f0\i0 \cf4 \strokec4 ]]\cb1 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 calculateDistance\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 a1
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 a2
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 math\cf4 \ulnone \strokec4 .\cf5 \strokec5 sqrt\cf4 \strokec4 ((
\f1\i \cf9 \strokec9 a1
\f0\i0 \cf4 \strokec4 [\cf6 \strokec6 2\cf4 \strokec4 ]\cf2 \strokec2 -
\f1\i \cf9 \strokec9 a2
\f0\i0 \cf4 \strokec4 [\cf6 \strokec6 2\cf4 \strokec4 ])\cf2 \strokec2 **\cf6 \strokec6 2\cf2 \strokec2 +\cf4 \strokec4 (
\f1\i \cf9 \strokec9 a1
\f0\i0 \cf4 \strokec4 [\cf6 \strokec6 3\cf4 \strokec4 ]\cf2 \strokec2 -
\f1\i \cf9 \strokec9 a2
\f0\i0 \cf4 \strokec4 [\cf6 \strokec6 3\cf4 \strokec4 ])\cf2 \strokec2 **\cf6 \strokec6 2\cf2 \strokec2 +\cf4 \strokec4 (
\f1\i \cf9 \strokec9 a1
\f0\i0 \cf4 \strokec4 [\cf6 \strokec6 4\cf4 \strokec4 ]\cf2 \strokec2 -
\f1\i \cf9 \strokec9 a2
\f0\i0 \cf4 \strokec4 [\cf6 \strokec6 4\cf4 \strokec4 ])\cf2 \strokec2 **\cf6 \strokec6 2\cf4 \strokec4 )\cb1 \
\cb3     \cb1 \
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 adjacencyMatrix\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 atom
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         kNeighbors \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 getNeighbors\cf4 \strokec4 (
\f1\i \cf9 \strokec9 atom
\f0\i0 \cf4 \strokec4 )\cb1 \
\cb3         matrix \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 zeros\cf4 \strokec4 ((\cf5 \strokec5 len\cf4 \strokec4 (kNeighbors), \cf5 \strokec5 len\cf4 \strokec4 (kNeighbors)))\cb1 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 range\cf4 \ulnone \strokec4 (\cf5 \strokec5 len\cf4 \strokec4 (kNeighbors)):\cb1 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  j \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 range\cf4 \ulnone \strokec4 (\cf5 \strokec5 len\cf4 \strokec4 (kNeighbors)):\cb1 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  kNeighbors[i] \cf2 \strokec2 !=\cf4 \strokec4  kNeighbors[j]:\cb1 \
\cb3                     \cf2 \strokec2 if\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 calculateDistance\cf4 \strokec4 (kNeighbors[i][\cf6 \strokec6 0\cf4 \strokec4 ], kNeighbors[j][\cf6 \strokec6 0\cf4 \strokec4 ]) \cf2 \strokec2 <=\cf4 \strokec4  \cf6 \strokec6 1.55\cf4 \strokec4 :\cb1 \
\cb3                         matrix[i,j] \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 1\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  matrix\cb1 \
\cb3     \cb1 \
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 featureMatrix\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 atom
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf10 \strokec10 '''\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb3 \strokec10         Get the feature Matrix for the atom and its neighbors.\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         ---\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         Position and description:\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         []\cf4 \cb1 \strokec4 \
\
\cf10 \cb3 \strokec10         '''\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3         sasa \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 sasaList\cf4 \strokec4 ()\cb1 \
\cb3         data \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 getNeighbors\cf4 \strokec4 (
\f1\i \cf9 \strokec9 atom
\f0\i0 \cf4 \strokec4 )\cb1 \
\cb3         \cf5 \strokec5 print\cf4 \strokec4 (data)\cb1 \
\cb3         directions \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 directions\cf4 \strokec4 (data)\cb1 \
\cb3         \cf8 \strokec8 # eDensity = self.electronDensity(data)\cf4 \cb1 \strokec4 \
\cb3         ljP \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 lj_potential\cf4 \strokec4 (data)\cb1 \
\cb3         secondary \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 secondaryList\cf4 \strokec4 ()\cb1 \
\cb3         \cf5 \strokec5 print\cf4 \strokec4 (secondary)\cb1 \
\cb3         featMat \cf2 \strokec2 =\cf4 \strokec4  []\cb1 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  atomFeature, potential, direction \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 zip\cf4 \ulnone \strokec4 (data, ljP, directions):\cb1 \
\cb3             distance \cf2 \strokec2 =\cf4 \strokec4  atomFeature[\cf6 \strokec6 1\cf4 \strokec4 ]\cb1 \
\cb3             atomFeature \cf2 \strokec2 =\cf4 \strokec4  atomFeature[\cf6 \strokec6 0\cf4 \strokec4 ]\cb1 \
\
\cb3             atomFeature.append(sasa[atomFeature[\cf6 \strokec6 0\cf4 \strokec4 ]\cf2 \strokec2 -\cf6 \strokec6 1\cf4 \strokec4 ])\cb1 \
\
\cb3             \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  potential:\cb1 \
\cb3                 atomFeature.append(i)\cb1 \
\
\cb3             \cf2 \strokec2 for\cf4 \strokec4  d \cf2 \strokec2 in\cf4 \strokec4  [\cf5 \ul \ulc5 \strokec5 chem\cf4 \ulnone \strokec4 .dictionary_kd_hydrophobicity, \cf5 \ul \ulc5 \strokec5 chem\cf4 \ulnone \strokec4 .dictionary_ww_hydrophobicity, \cf5 \ul \ulc5 \strokec5 chem\cf4 \ulnone \strokec4 .dictionary_hh_hydrophobicity, \cf5 \ul \ulc5 \strokec5 chem\cf4 \ulnone \strokec4 .dictionary_mf_hydrophobicity, \cf5 \ul \ulc5 \strokec5 chem\cf4 \ulnone \strokec4 .dictionary_tt_hydrophobicity]:\cb1 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  atomFeature[\cf6 \strokec6 7\cf4 \strokec4 ] \cf2 \strokec2 not\cf4 \strokec4  \cf2 \strokec2 in\cf4 \strokec4  d:\cb1 \
\cb3                     \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 range\cf4 \ulnone \strokec4 (\cf6 \strokec6 5\cf4 \strokec4 ):\cb1 \
\cb3                         atomFeature.append(\cf6 \strokec6 0\cf4 \strokec4 )\cb1 \
\cb3                 \cf2 \strokec2 else\cf4 \strokec4 :\cb1 \
\cb3                     atomFeature.append(\cf5 \ul \ulc5 \strokec5 chem\cf4 \ulnone \strokec4 .dictionary_kd_hydrophobicity[atomFeature[\cf6 \strokec6 7\cf4 \strokec4 ]])\cb1 \
\cb3                     atomFeature.append(\cf5 \ul \ulc5 \strokec5 chem\cf4 \ulnone \strokec4 .dictionary_ww_hydrophobicity[atomFeature[\cf6 \strokec6 7\cf4 \strokec4 ]])\cb1 \
\cb3                     atomFeature.append(\cf5 \ul \ulc5 \strokec5 chem\cf4 \ulnone \strokec4 .dictionary_hh_hydrophobicity[atomFeature[\cf6 \strokec6 7\cf4 \strokec4 ]])\cb1 \
\cb3                     atomFeature.append(\cf5 \ul \ulc5 \strokec5 chem\cf4 \ulnone \strokec4 .dictionary_mf_hydrophobicity[atomFeature[\cf6 \strokec6 7\cf4 \strokec4 ]])\cb1 \
\cb3                     atomFeature.append(\cf5 \ul \ulc5 \strokec5 chem\cf4 \ulnone \strokec4 .dictionary_tt_hydrophobicity[atomFeature[\cf6 \strokec6 7\cf4 \strokec4 ]])\cb1 \
\cb3             \cb1 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  direction:\cb1 \
\cb3                 atomFeature.append(i)\cb1 \
\
\
\
\
\
\
\cb3             \cf8 \strokec8 # del atomFeature[0]\cf4 \cb1 \strokec4 \
\cb3             \cf8 \strokec8 # del atomFeature[0]\cf4 \cb1 \strokec4 \
\cb3             \cf8 \strokec8 # del atomFeature[3]\cf4 \cb1 \strokec4 \
\cb3             \cf8 \strokec8 # del atomFeature[3]\cf4 \cb1 \strokec4 \
\cb3             \cf8 \strokec8 # del atomFeature[3]\cf4 \cb1 \strokec4 \
\cb3             \cf8 \strokec8 # # print(atomFeature)\cf4 \cb1 \strokec4 \
\cb3             \cf8 \strokec8 # # del atomFeature[]\cf4 \cb1 \strokec4 \
\
\cb3             \cf8 \strokec8 # del atomFeature[0:3]\cf4 \cb1 \strokec4 \
\cb3             \cf8 \strokec8 # del atomFeature[2:]\cf4 \cb1 \strokec4 \
\
\
\cb3             \cf5 \strokec5 print\cf4 \strokec4 (atomFeature)\cb1 \
\
\cb3             featMat.\cf5 \strokec5 append\cf4 \strokec4 (atomFeature)\cb1 \
\
\cb3         \cf2 \strokec2 return\cf4 \strokec4  featMat\cb1 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 directions\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 data
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         given_atom \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 data
\f0\i0 \cf4 \strokec4 [\cf6 \strokec6 0\cf4 \strokec4 ][\cf6 \strokec6 0\cf4 \strokec4 ][\cf6 \strokec6 2\cf4 \strokec4 :\cf6 \strokec6 5\cf4 \strokec4 ]\cb1 \
\cb3         neighbor_atoms \cf2 \strokec2 =\cf4 \strokec4  []\cb1 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 data
\f0\i0 \cf4 \strokec4 :\cb1 \
\cb3             neighbor_atoms.\cf5 \strokec5 append\cf4 \strokec4 (i[\cf6 \strokec6 0\cf4 \strokec4 ][\cf6 \strokec6 2\cf4 \strokec4 :\cf6 \strokec6 5\cf4 \strokec4 ])\cb1 \
\cb3         given_atom \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 (given_atom)\cb1 \
\cb3         neighbor_atoms \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 (neighbor_atoms)\cb1 \
\cb3         directions \cf2 \strokec2 =\cf4 \strokec4  neighbor_atoms\cf2 \strokec2 -\cf4 \strokec4 given_atom\cb1 \
\
\cb3         \cf2 \strokec2 return\cf4 \strokec4  directions\cb1 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 sasa\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         sasa \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 ShrakeRupley\cf4 \ulnone \strokec4 ()\cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  sasa.\cf5 \strokec5 compute\cf4 \strokec4 (\cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .atoms()))\cb1 \
\cb3     \cb1 \
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 sasaList\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._sasa \cf2 \strokec2 is\cf4 \strokec4  \cf6 \strokec6 None\cf4 \strokec4 :\cb1 \
\cb3             sasa \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 ([])\cb1 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 sasa\cf4 \strokec4 ():\cb1 \
\cb3                 sasa \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 append\cf4 \strokec4 (sasa, i)\cb1 \
\cb3             
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._sasa \cf2 \strokec2 =\cf4 \strokec4  sasa\cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._sasa\cb1 \
\cb3     \cb1 \
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 coords\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._mol_dict \cf2 \strokec2 is\cf4 \strokec4  \cf6 \strokec6 None\cf4 \strokec4 :\cb1 \
\cb3             moleculeList \cf2 \strokec2 =\cf4 \strokec4  []\cb1 \
\cb3             c \cf2 \strokec2 =\cf4 \strokec4  []\cb1 \
\cb3             smallDict \cf2 \strokec2 =\cf4 \strokec4  \{\}\cb1 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .atoms():\cb1 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  i[\cf6 \strokec6 6\cf4 \strokec4 ] \cf2 \strokec2 not\cf4 \strokec4  \cf2 \strokec2 in\cf4 \strokec4  c:\cb1 \
\cb3                     \cf2 \strokec2 if\cf4 \strokec4  i[\cf6 \strokec6 1\cf4 \strokec4 ] \cf2 \strokec2 ==\cf4 \strokec4  \cf10 \strokec10 'N'\cf4 \strokec4 :\cb1 \
\cb3                         smallDict[\cf10 \strokec10 'N'\cf4 \strokec4 ] \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 ([i[\cf6 \strokec6 2\cf4 \strokec4 ], i[\cf6 \strokec6 3\cf4 \strokec4 ], i[\cf6 \strokec6 4\cf4 \strokec4 ]])\cb1 \
\cb3                     \cf2 \strokec2 elif\cf4 \strokec4  i[\cf6 \strokec6 1\cf4 \strokec4 ] \cf2 \strokec2 ==\cf4 \strokec4  \cf10 \strokec10 'CA'\cf4 \strokec4 :\cb1 \
\cb3                         smallDict[\cf10 \strokec10 'CA'\cf4 \strokec4 ] \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 ([i[\cf6 \strokec6 2\cf4 \strokec4 ], i[\cf6 \strokec6 3\cf4 \strokec4 ], i[\cf6 \strokec6 4\cf4 \strokec4 ]])\cb1 \
\cb3                     \cf2 \strokec2 elif\cf4 \strokec4  i[\cf6 \strokec6 1\cf4 \strokec4 ] \cf2 \strokec2 ==\cf4 \strokec4  \cf10 \strokec10 'C'\cf4 \strokec4 :\cb1 \
\cb3                         smallDict[\cf10 \strokec10 'C'\cf4 \strokec4 ] \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 ([i[\cf6 \strokec6 2\cf4 \strokec4 ], i[\cf6 \strokec6 3\cf4 \strokec4 ], i[\cf6 \strokec6 4\cf4 \strokec4 ]])\cb1 \
\cb3                     \cf2 \strokec2 elif\cf4 \strokec4  i[\cf6 \strokec6 1\cf4 \strokec4 ] \cf2 \strokec2 ==\cf4 \strokec4  \cf10 \strokec10 'O'\cf4 \strokec4 :\cb1 \
\cb3                         smallDict[\cf10 \strokec10 'O'\cf4 \strokec4 ] \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 ([i[\cf6 \strokec6 2\cf4 \strokec4 ], i[\cf6 \strokec6 3\cf4 \strokec4 ], i[\cf6 \strokec6 4\cf4 \strokec4 ]])\cb1 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  \cf5 \strokec5 len\cf4 \strokec4 (smallDict) \cf2 \strokec2 ==\cf4 \strokec4  \cf6 \strokec6 4\cf4 \strokec4 :\cb1 \
\cb3                     moleculeList.\cf5 \strokec5 append\cf4 \strokec4 (smallDict)\cb1 \
\cb3                     smallDict \cf2 \strokec2 =\cf4 \strokec4  \{\}\cb1 \
\cb3             
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._mol_dict \cf2 \strokec2 =\cf4 \strokec4  moleculeList\cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._mol_dict\cb1 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 secondaryList\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._secondary \cf2 \strokec2 is\cf4 \strokec4  \cf6 \strokec6 None\cf4 \strokec4 :\cb1 \
\cb3             sec \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 ([])\cb1 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 calculate_secondary_structure\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 coords\cf4 \strokec4 ()):\cb1 \
\cb3                 sec \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 append\cf4 \strokec4 (sec, i)\cb1 \
\cb3             
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._secondary \cf2 \strokec2 =\cf4 \strokec4  sec\cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._secondary\cb1 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 calculate_secondary_structure\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf8 \strokec8 # Define the hydrogen bonding distance cutoffs for each type of interaction\cf4 \cb1 \strokec4 \
\cb3         hbond_cutoffs \cf2 \strokec2 =\cf4 \strokec4  \{\cf10 \strokec10 'helix'\cf4 \strokec4 : \cf6 \strokec6 4.6\cf4 \strokec4 , \cf10 \strokec10 'sheet'\cf4 \strokec4 : \cf6 \strokec6 3.5\cf4 \strokec4 \}\cb1 \
\cb3         \cb1 \
\cb3         \cf8 \strokec8 # Define the angles for each type of secondary structure\cf4 \cb1 \strokec4 \
\cb3         helix_angles \cf2 \strokec2 =\cf4 \strokec4  \{\cf10 \strokec10 'C-alpha-C'\cf4 \strokec4 : \cf6 \strokec6 1.5\cf4 \strokec4 , \cf10 \strokec10 'C-N-C-alpha'\cf4 \strokec4 : \cf6 \strokec6 2.0\cf4 \strokec4 \}\cb1 \
\cb3         sheet_angles \cf2 \strokec2 =\cf4 \strokec4  \{\cf10 \strokec10 'C-alpha-C'\cf4 \strokec4 : \cf6 \strokec6 2.0\cf4 \strokec4 , \cf10 \strokec10 'C-N-C-alpha'\cf4 \strokec4 : \cf6 \strokec6 1.5\cf4 \strokec4 \}\cb1 \
\cb3         \cb1 \
\cb3         \cf8 \strokec8 # Initialize the secondary structure assignment for each residue\cf4 \cb1 \strokec4 \
\cb3         sec_struct \cf2 \strokec2 =\cf4 \strokec4  [\cf10 \strokec10 '?'\cf4 \strokec4  \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 range\cf4 \ulnone \strokec4 (\cf5 \strokec5 len\cf4 \strokec4 (
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 ))]\cb1 \
\cb3         \cb1 \
\cb3         \cf8 \strokec8 # Iterate over each residue and compare its hydrogen bonding distance to adjacent residues\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 range\cf4 \ulnone \strokec4 (\cf5 \strokec5 len\cf4 \strokec4 (
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 )):\cb1 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  j \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 range\cf4 \ulnone \strokec4 (i\cf2 \strokec2 +\cf6 \strokec6 1\cf4 \strokec4 , \cf5 \strokec5 len\cf4 \strokec4 (
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 )):\cb1 \
\cb3                 \cf8 \strokec8 # print(coords[i]['N'], coords[j]['O'], np.linalg.norm(coords[i]['N'] - coords[j]['O']))\cf4 \cb1 \strokec4 \
\cb3                 dist \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \ul \ulc5 \strokec5 linalg\cf4 \ulnone \strokec4 .\cf5 \strokec5 norm\cf4 \strokec4 (
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [i][\cf10 \strokec10 'N'\cf4 \strokec4 ] \cf2 \strokec2 -\cf4 \strokec4  
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [j][\cf10 \strokec10 'O'\cf4 \strokec4 ])\cb1 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  dist \cf2 \strokec2 <\cf4 \strokec4  hbond_cutoffs[\cf10 \strokec10 'helix'\cf4 \strokec4 ]:\cb1 \
\cb3                     \cf5 \strokec5 print\cf4 \strokec4 (\cf10 \strokec10 'hey'\cf4 \strokec4 )\cb1 \
\cb3                     \cf8 \strokec8 # Check if the angle between the C-alpha, C, and N atoms is within the helix range\cf4 \cb1 \strokec4 \
\cb3                     angle1 \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 calculate_angle\cf4 \strokec4 (
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [i][\cf10 \strokec10 'CA'\cf4 \strokec4 ], 
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [i][\cf10 \strokec10 'C'\cf4 \strokec4 ], 
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [j][\cf10 \strokec10 'N'\cf4 \strokec4 ])\cb1 \
\cb3                     angle2 \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 calculate_angle\cf4 \strokec4 (
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [j][\cf10 \strokec10 'C'\cf4 \strokec4 ], 
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [j][\cf10 \strokec10 'N'\cf4 \strokec4 ], 
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [i][\cf10 \strokec10 'CA'\cf4 \strokec4 ])\cb1 \
\cb3                     \cf2 \strokec2 if\cf4 \strokec4  \cf5 \strokec5 abs\cf4 \strokec4 (angle1 \cf2 \strokec2 -\cf4 \strokec4  helix_angles[\cf10 \strokec10 'C-alpha-C'\cf4 \strokec4 ]) \cf2 \strokec2 <\cf4 \strokec4  \cf6 \strokec6 0.5\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  \cf5 \strokec5 abs\cf4 \strokec4 (angle2 \cf2 \strokec2 -\cf4 \strokec4  helix_angles[\cf10 \strokec10 'C-N-C-alpha'\cf4 \strokec4 ]) \cf2 \strokec2 <\cf4 \strokec4  \cf6 \strokec6 0.5\cf4 \strokec4 :\cb1 \
\cb3                         sec_struct[i] \cf2 \strokec2 =\cf4 \strokec4  \cf10 \strokec10 'H'\cf4 \cb1 \strokec4 \
\cb3                         sec_struct[j] \cf2 \strokec2 =\cf4 \strokec4  \cf10 \strokec10 'H'\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 elif\cf4 \strokec4  dist \cf2 \strokec2 <\cf4 \strokec4  hbond_cutoffs[\cf10 \strokec10 'sheet'\cf4 \strokec4 ]:\cb1 \
\cb3                     \cf8 \strokec8 # Check if the angle between the C-alpha, C, and N atoms is within the sheet range\cf4 \cb1 \strokec4 \
\cb3                     angle1 \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 calculate_angle\cf4 \strokec4 (
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [i][\cf10 \strokec10 'CA'\cf4 \strokec4 ], 
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [i][\cf10 \strokec10 'C'\cf4 \strokec4 ], 
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [j][\cf10 \strokec10 'N'\cf4 \strokec4 ])\cb1 \
\cb3                     angle2 \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 calculate_angle\cf4 \strokec4 (
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [j][\cf10 \strokec10 'C'\cf4 \strokec4 ], 
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [j][\cf10 \strokec10 'N'\cf4 \strokec4 ], 
\f1\i \cf9 \strokec9 coords
\f0\i0 \cf4 \strokec4 [i][\cf10 \strokec10 'CA'\cf4 \strokec4 ])\cb1 \
\cb3                     \cf2 \strokec2 if\cf4 \strokec4  \cf5 \strokec5 abs\cf4 \strokec4 (angle1 \cf2 \strokec2 -\cf4 \strokec4  sheet_angles[\cf10 \strokec10 'C-alpha-C'\cf4 \strokec4 ]) \cf2 \strokec2 <\cf4 \strokec4  \cf6 \strokec6 0.5\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  \cf5 \strokec5 abs\cf4 \strokec4 (angle2 \cf2 \strokec2 -\cf4 \strokec4  sheet_angles[\cf10 \strokec10 'C-N-C-alpha'\cf4 \strokec4 ]) \cf2 \strokec2 <\cf4 \strokec4  \cf6 \strokec6 0.5\cf4 \strokec4 :\cb1 \
\cb3                         sec_struct[i] \cf2 \strokec2 =\cf4 \strokec4  \cf10 \strokec10 'E'\cf4 \cb1 \strokec4 \
\cb3                         sec_struct[j] \cf2 \strokec2 =\cf4 \strokec4  \cf10 \strokec10 'E'\cf4 \cb1 \strokec4 \
\cb3         \cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  sec_struct\cb1 \
\
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 calculate_angle\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 p1
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 p2
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 p3
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         v1 \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 p1
\f0\i0 \cf4 \strokec4  \cf2 \strokec2 -\cf4 \strokec4  
\f1\i \cf9 \strokec9 p2
\f0\i0 \cf4 \cb1 \strokec4 \
\cb3         v2 \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 p3
\f0\i0 \cf4 \strokec4  \cf2 \strokec2 -\cf4 \strokec4  
\f1\i \cf9 \strokec9 p2
\f0\i0 \cf4 \cb1 \strokec4 \
\cb3         cos_theta \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 dot\cf4 \strokec4 (v1, v2) \cf2 \strokec2 /\cf4 \strokec4  (\cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \ul \ulc5 \strokec5 linalg\cf4 \ulnone \strokec4 .\cf5 \strokec5 norm\cf4 \strokec4 (v1) \cf2 \strokec2 *\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \ul \ulc5 \strokec5 linalg\cf4 \ulnone \strokec4 .\cf5 \strokec5 norm\cf4 \strokec4 (v2))\cb1 \
\cb3         theta \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .arccos(cos_theta)\cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  theta \cf2 \strokec2 *\cf4 \strokec4  \cf6 \strokec6 180\cf4 \strokec4  \cf2 \strokec2 /\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .pi\cb1 \
\
\
\
\cb3     \cf8 \strokec8 # def electronDensity(self, data):\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #     dataStr = ''\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #     for i in data:\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #         goodData = [i[0][5].split('.')[0], str(i[0][2]), str(i[0][3]), str(i[0][4])]\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #         print(goodData)\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #         dataStr += '  '.join(goodData) + '\\n'\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #     print(dataStr)\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #     mol = pyscf.gto.M(atom=dataStr, basis='sto-3g')\cf4 \cb1 \strokec4 \
\
\
\cb3     \cf8 \strokec8 #     # Compute the molecular orbitals\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #     mf = pyscf.scf.RHF(mol)\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #     mf.kernel()\cf4 \cb1 \strokec4 \
\
\cb3     \cf8 \strokec8 #     # Compute the electron density matrix\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #     dm = mf.make_rdm1()\cf4 \cb1 \strokec4 \
\
\cb3     \cf8 \strokec8 #     # Compute the electron density of each atom\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #     electron_density = mol.atom_charges()[:, None] - dm.diagonal()\cf4 \cb1 \strokec4 \
\
\cb3     \cf8 \strokec8 #     for i in electron_density:\cf4 \cb1 \strokec4 \
\cb3     \cf8 \strokec8 #         print(len(i), i)\cf4 \cb1 \strokec4 \
\
\cb3     \cf8 \strokec8 #     return data\cf4 \cb1 \strokec4 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 lj_potential\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 data
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf10 \strokec10 """\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb3 \strokec10         Compute the Lennard-Jones potential energy.\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         Returns a Matrix with the energies computed between all the neighbors atoms.\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         """\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3         dataMatrix \cf2 \strokec2 =\cf4 \strokec4  []\cb1 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 data
\f0\i0 \cf4 \strokec4 :\cb1 \
\cb3             dataRow \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 ([i[\cf6 \strokec6 0\cf4 \strokec4 ][\cf6 \strokec6 5\cf4 \strokec4 ].split(\cf10 \strokec10 '.'\cf4 \strokec4 )[\cf6 \strokec6 0\cf4 \strokec4 ], i[\cf6 \strokec6 0\cf4 \strokec4 ][\cf6 \strokec6 2\cf4 \strokec4 ], i[\cf6 \strokec6 0\cf4 \strokec4 ][\cf6 \strokec6 3\cf4 \strokec4 ], i[\cf6 \strokec6 0\cf4 \strokec4 ][\cf6 \strokec6 4\cf4 \strokec4 ]])\cb1 \
\cb3             dataMatrix.\cf5 \strokec5 append\cf4 \strokec4 (dataRow)\cb1 \
\cb3         dataMatrix \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 (dataMatrix)\cb1 \
\cb3         \cf8 \strokec8 # print(dataMatrix)\cf4 \cb1 \strokec4 \
\cb3         m, n \cf2 \strokec2 =\cf4 \strokec4  dataMatrix.shape\cb1 \
\cb3         ljP \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 empty\cf4 \strokec4 ([m,m])\cb1 \
\cb3         bond \cf2 \strokec2 =\cf4 \strokec4  \cf10 \strokec10 ''\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 range\cf4 \ulnone \strokec4 (m):\cb1 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  j \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 range\cf4 \ulnone \strokec4 (m):\cb1 \
\cb3                 r \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 math\cf4 \ulnone \strokec4 .\cf5 \strokec5 sqrt\cf4 \strokec4 ((\cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (dataMatrix[i, \cf6 \strokec6 1\cf4 \strokec4 ])\cf2 \strokec2 -\cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (dataMatrix[j, \cf6 \strokec6 1\cf4 \strokec4 ]))\cf2 \strokec2 **\cf6 \strokec6 2\cf2 \strokec2 +\cf4 \strokec4 (\cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (dataMatrix[i, \cf6 \strokec6 2\cf4 \strokec4 ])\cf2 \strokec2 -\cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (dataMatrix[j, \cf6 \strokec6 2\cf4 \strokec4 ]))\cf2 \strokec2 **\cf6 \strokec6 2\cf2 \strokec2 +\cf4 \strokec4 (\cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (dataMatrix[i, \cf6 \strokec6 3\cf4 \strokec4 ])\cf2 \strokec2 -\cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (dataMatrix[j, \cf6 \strokec6 3\cf4 \strokec4 ]))\cf2 \strokec2 **\cf6 \strokec6 2\cf4 \strokec4 )\cb1 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  \cf5 \strokec5 len\cf4 \strokec4 (\cf5 \ul \ulc5 \strokec5 str\cf4 \ulnone \strokec4 (dataMatrix[i, \cf6 \strokec6 0\cf4 \strokec4 ])) \cf2 \strokec2 ==\cf4 \strokec4  \cf6 \strokec6 1\cf4 \strokec4 :\cb1 \
\cb3                     bond \cf2 \strokec2 =\cf4 \strokec4  dataMatrix[i, \cf6 \strokec6 0\cf4 \strokec4 ]\cf2 \strokec2 +\cf10 \strokec10 " -"\cf2 \strokec2 +\cf4 \strokec4 dataMatrix[j, \cf6 \strokec6 0\cf4 \strokec4 ]\cb1 \
\cb3                 \cf2 \strokec2 elif\cf4 \strokec4  \cf5 \strokec5 len\cf4 \strokec4 (\cf5 \ul \ulc5 \strokec5 str\cf4 \ulnone \strokec4 (dataMatrix[i, \cf6 \strokec6 0\cf4 \strokec4 ])) \cf2 \strokec2 ==\cf4 \strokec4  \cf6 \strokec6 2\cf4 \strokec4 :\cb1 \
\cb3                     bond \cf2 \strokec2 =\cf4 \strokec4  dataMatrix[i, \cf6 \strokec6 0\cf4 \strokec4 ]\cf2 \strokec2 +\cf10 \strokec10 "-"\cf2 \strokec2 +\cf4 \strokec4 dataMatrix[j, \cf6 \strokec6 0\cf4 \strokec4 ]\cb1 \
\cb3                 \cf8 \strokec8 # print('Bond', bond)\cf4 \cb1 \strokec4 \
\cb3                 \cf8 \strokec8 # with open('parm99.dat') as ff:\cf4 \cb1 \strokec4 \
\cb3                 eps \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 0\cf4 \cb1 \strokec4 \
\cb3                 sig \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 0\cf4 \cb1 \strokec4 \
\cb3                 \cf8 \strokec8 # for line in ff:\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 for\cf4 \strokec4  line \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 readAtomES\cf4 \strokec4 ():\cb1 \
\cb3                     \cf2 \strokec2 if\cf4 \strokec4  line.\cf5 \strokec5 startswith\cf4 \strokec4 (bond):\cb1 \
\cb3                         eps \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 7\cf4 \strokec4 :\cf6 \strokec6 12\cf4 \strokec4 ])\cb1 \
\cb3                         sig \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 16\cf4 \strokec4 :\cf6 \strokec6 22\cf4 \strokec4 ])\cb1 \
\cb3                         \cf8 \strokec8 # print(eps, sig)\cf4 \cb1 \strokec4 \
\cb3                         \cf2 \strokec2 break\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  eps \cf2 \strokec2 ==\cf4 \strokec4  \cf6 \strokec6 0\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  sig \cf2 \strokec2 ==\cf4 \strokec4  \cf6 \strokec6 0\cf4 \strokec4 :\cb1 \
\cb3                     \cf2 \strokec2 if\cf4 \strokec4  \cf5 \strokec5 len\cf4 \strokec4 (\cf5 \ul \ulc5 \strokec5 str\cf4 \ulnone \strokec4 (dataMatrix[i, \cf6 \strokec6 0\cf4 \strokec4 ])) \cf2 \strokec2 ==\cf4 \strokec4  \cf6 \strokec6 1\cf4 \strokec4 :\cb1 \
\cb3                         bond \cf2 \strokec2 =\cf4 \strokec4  dataMatrix[j, \cf6 \strokec6 0\cf4 \strokec4 ]\cf2 \strokec2 +\cf10 \strokec10 " -"\cf2 \strokec2 +\cf4 \strokec4 dataMatrix[i, \cf6 \strokec6 0\cf4 \strokec4 ]\cb1 \
\cb3                     \cf2 \strokec2 elif\cf4 \strokec4  \cf5 \strokec5 len\cf4 \strokec4 (\cf5 \ul \ulc5 \strokec5 str\cf4 \ulnone \strokec4 (dataMatrix[i, \cf6 \strokec6 0\cf4 \strokec4 ])) \cf2 \strokec2 ==\cf4 \strokec4  \cf6 \strokec6 2\cf4 \strokec4 :\cb1 \
\cb3                         bond \cf2 \strokec2 =\cf4 \strokec4  dataMatrix[j, \cf6 \strokec6 0\cf4 \strokec4 ]\cf2 \strokec2 +\cf10 \strokec10 "-"\cf2 \strokec2 +\cf4 \strokec4 dataMatrix[i, \cf6 \strokec6 0\cf4 \strokec4 ]\cb1 \
\cb3                     \cf8 \strokec8 # with open('parm99.dat') as ff:\cf4 \cb1 \strokec4 \
\cb3                         \cf8 \strokec8 # eps = 0\cf4 \cb1 \strokec4 \
\cb3                         \cf8 \strokec8 # sig = 0\cf4 \cb1 \strokec4 \
\cb3                         \cf8 \strokec8 # for line in ff:\cf4 \cb1 \strokec4 \
\cb3                     \cf2 \strokec2 for\cf4 \strokec4  line \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 readAtomES\cf4 \strokec4 ():\cb1 \
\cb3                         \cf8 \strokec8 # print('Second:', line)\cf4 \cb1 \strokec4 \
\cb3                         \cf2 \strokec2 if\cf4 \strokec4  line.\cf5 \strokec5 startswith\cf4 \strokec4 (bond):\cb1 \
\cb3                             eps \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 7\cf4 \strokec4 :\cf6 \strokec6 12\cf4 \strokec4 ])\cb1 \
\cb3                             sig \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 16\cf4 \strokec4 :\cf6 \strokec6 22\cf4 \strokec4 ])\cb1 \
\cb3                             \cf8 \strokec8 # print(eps, sig)\cf4 \cb1 \strokec4 \
\cb3                             \cf2 \strokec2 break\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  r \cf2 \strokec2 !=\cf4 \strokec4  \cf6 \strokec6 0\cf4 \strokec4 :\cb1 \
\cb3                     ljP[i, j] \cf2 \strokec2 =\cf4 \strokec4  \cf10 \strokec10 "\cf6 \strokec6 \{
\f1\i \cf7 \strokec7 :.3
\f0\i0 \cf6 \strokec6 \}\cf10 \strokec10 "\cf4 \strokec4 .\cf5 \strokec5 format\cf4 \strokec4 (\cf6 \strokec6 4\cf4 \strokec4  \cf2 \strokec2 *\cf4 \strokec4  eps \cf2 \strokec2 *\cf4 \strokec4  ((sig \cf2 \strokec2 /\cf4 \strokec4  r) \cf2 \strokec2 **\cf4 \strokec4  \cf6 \strokec6 12\cf4 \strokec4  \cf2 \strokec2 -\cf4 \strokec4  (sig \cf2 \strokec2 /\cf4 \strokec4  r) \cf2 \strokec2 **\cf4 \strokec4  \cf6 \strokec6 6\cf4 \strokec4 ))\cb1 \
\cb3                 \cf2 \strokec2 else\cf4 \strokec4 :\cb1 \
\cb3                     ljP[i, j] \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 0\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 # print(ljP)\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  ljP\cb1 \
\cb3     \cb1 \
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 readAtomES\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf2 \strokec2 with\cf4 \strokec4  \cf5 \strokec5 open\cf4 \strokec4 (\cf10 \strokec10 'parm99.dat'\cf4 \strokec4 ) \cf2 \strokec2 as\cf4 \strokec4  ff:\cb1 \
\cb3             \cf2 \strokec2 yield from\cf4 \strokec4  ff\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f1\i \cf7 \cb3 \strokec7 class
\f0\i0 \cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 readMod2\cf4 \ulnone \strokec4 (\cf5 \ul \ulc5 \strokec5 readprotein\cf4 \ulnone \strokec4 ):\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     \cf10 \strokec10 '''\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb3 \strokec10     Explicit to read the mol2 file\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10     '''\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 atoms\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         atom_lines \cf2 \strokec2 =\cf4 \strokec4  []\cb1 \
\cb3         collect_atoms \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 False\cf4 \cb1 \strokec4 \
\cb3         i \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 1\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  line \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 data\cf4 \strokec4 ():\cb1 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  \cf10 \strokec10 '@<TRIPOS>ATOM'\cf4 \strokec4  \cf2 \strokec2 in\cf4 \strokec4  line:\cb1 \
\cb3                 collect_atoms \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 True\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 continue\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  collect_atoms:\cb1 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  line.\cf5 \strokec5 startswith\cf4 \strokec4 (\cf10 \strokec10 '@<TRIPOS>'\cf4 \strokec4 ):\cb1 \
\cb3                     \cf2 \strokec2 break\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  line[\cf6 \strokec6 49\cf4 \strokec4 ] \cf2 \strokec2 !=\cf4 \strokec4  \cf10 \strokec10 'H'\cf4 \strokec4 :\cb1 \
\cb3                     \cf2 \strokec2 if\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 str\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 64\cf4 \strokec4 :\cf6 \strokec6 71\cf4 \strokec4 ]).\cf5 \strokec5 strip\cf4 \strokec4 ()[:\cf6 \strokec6 3\cf4 \strokec4 ] \cf2 \strokec2 !=\cf4 \strokec4  \cf10 \strokec10 'HOH'\cf4 \strokec4 :\cb1 \
\cb3                         \cf8 \strokec8 # aNum = int(line[0:6])\cf4 \cb1 \strokec4 \
\cb3                         aNum \cf2 \strokec2 =\cf4 \strokec4  i\cb1 \
\cb3                         aType \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 str\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 7\cf4 \strokec4 :\cf6 \strokec6 14\cf4 \strokec4 ]).\cf5 \strokec5 strip\cf4 \strokec4 ()\cb1 \
\cb3                         aX \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 17\cf4 \strokec4 :\cf6 \strokec6 26\cf4 \strokec4 ])\cb1 \
\cb3                         aY \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 28\cf4 \strokec4 :\cf6 \strokec6 37\cf4 \strokec4 ])\cb1 \
\cb3                         aZ \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 40\cf4 \strokec4 :\cf6 \strokec6 48\cf4 \strokec4 ])\cb1 \
\cb3                         aType2 \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 str\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 49\cf4 \strokec4 :\cf6 \strokec6 56\cf4 \strokec4 ]).\cf5 \strokec5 strip\cf4 \strokec4 ()\cb1 \
\cb3                         rNum \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 int\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 58\cf4 \strokec4 :\cf6 \strokec6 63\cf4 \strokec4 ])\cb1 \
\cb3                         rType \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 str\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 64\cf4 \strokec4 :\cf6 \strokec6 71\cf4 \strokec4 ]).\cf5 \strokec5 strip\cf4 \strokec4 ()\cb1 \
\cb3                         aCharge \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 72\cf4 \strokec4 :\cf6 \strokec6 79\cf4 \strokec4 ])\cb1 \
\cb3                         atom_lines.\cf5 \strokec5 append\cf4 \strokec4 ([aNum, aType, aX, aY, aZ, aType2, rNum, rType[\cf6 \strokec6 0\cf4 \strokec4 :\cf6 \strokec6 3\cf4 \strokec4 ], aCharge])\cb1 \
\cb3                         i\cf2 \strokec2 +=\cf6 \strokec6 1\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  atom_lines\cb1 \
\
\
\pard\pardeftab720\sl420\partightenfactor0

\f1\i \cf7 \cb3 \strokec7 class
\f0\i0 \cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 readpdb\cf4 \ulnone \strokec4 (\cf5 \ul \ulc5 \strokec5 readprotein\cf4 \ulnone \strokec4 ):\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     \cf10 \strokec10 '''\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb3 \strokec10     Explicit to read the pdb file\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10     '''\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     \cf2 \strokec2 pass\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f1\i \cf7 \cb3 \strokec7 class
\f0\i0 \cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 Mol2ligand\cf4 \ulnone \strokec4 ():\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf7 \strokec7 __init__\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 mol2ligand
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._ligand \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 mol2ligand
\f0\i0 \cf4 \cb1 \strokec4 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 readSolution\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf2 \strokec2 with\cf4 \strokec4  \cf5 \strokec5 open\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._ligand, \cf10 \strokec10 'r'\cf4 \strokec4 ) \cf2 \strokec2 as\cf4 \strokec4  fl:\cb1 \
\cb3             \cf2 \strokec2 yield from\cf4 \strokec4  fl\cb1 \
\cb3             \cf8 \strokec8 # ligand_data = fl.readlines()\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 # return ligand_data\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 points\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         points \cf2 \strokec2 =\cf4 \strokec4  []\cb1 \
\cb3         collect_atoms \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 False\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  line \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 readSolution\cf4 \strokec4 ():\cb1 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  \cf10 \strokec10 '@<TRIPOS>ATOM'\cf4 \strokec4  \cf2 \strokec2 in\cf4 \strokec4  line:\cb1 \
\cb3                 collect_atoms \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 True\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 continue\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  collect_atoms:\cb1 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  line.\cf5 \strokec5 startswith\cf4 \strokec4 (\cf10 \strokec10 '@<TRIPOS>'\cf4 \strokec4 ):\cb1 \
\cb3                     \cf2 \strokec2 break\cf4 \cb1 \strokec4 \
\cb3                 points.\cf5 \strokec5 append\cf4 \strokec4 ([\cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 17\cf4 \strokec4 :\cf6 \strokec6 25\cf4 \strokec4 ]), \cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 27\cf4 \strokec4 :\cf6 \strokec6 35\cf4 \strokec4 ]), \cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (line[\cf6 \strokec6 37\cf4 \strokec4 :\cf6 \strokec6 45\cf4 \strokec4 ])])\cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  points\cb1 \
\cb3         \cb1 \
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 SolutionsFeatureMatrix\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 matrix
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         solList \cf2 \strokec2 =\cf4 \strokec4  []\cb1 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  atom \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 matrix
\f0\i0 \cf4 \strokec4 :\cb1 \
\cb3             atom \cf2 \strokec2 =\cf4 \strokec4  atom[\cf6 \strokec6 0\cf4 \strokec4 ]\cb1 \
\cb3             ligand \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 0\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  cavity \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 points\cf4 \strokec4 ():\cb1 \
\cb3                 dist \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 math\cf4 \ulnone \strokec4 .\cf5 \strokec5 sqrt\cf4 \strokec4 ((atom[\cf6 \strokec6 2\cf4 \strokec4 ]\cf2 \strokec2 -\cf4 \strokec4 cavity[\cf6 \strokec6 0\cf4 \strokec4 ])\cf2 \strokec2 **\cf6 \strokec6 2\cf2 \strokec2 +\cf4 \strokec4 (atom[\cf6 \strokec6 3\cf4 \strokec4 ]\cf2 \strokec2 -\cf4 \strokec4 cavity[\cf6 \strokec6 1\cf4 \strokec4 ])\cf2 \strokec2 **\cf6 \strokec6 2\cf2 \strokec2 +\cf4 \strokec4 (atom[\cf6 \strokec6 4\cf4 \strokec4 ]\cf2 \strokec2 -\cf4 \strokec4 cavity[\cf6 \strokec6 2\cf4 \strokec4 ])\cf2 \strokec2 **\cf6 \strokec6 2\cf4 \strokec4 )\cb1 \
\cb3                 \cf8 \strokec8 # print([atom[2],cavity[0],atom[3],cavity[1],atom[4],cavity[2]])\cf4 \cb1 \strokec4 \
\cb3                 \cf8 \strokec8 # print(dist)\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  dist \cf2 \strokec2 <\cf4 \strokec4  \cf6 \strokec6 3.5\cf4 \strokec4 :\cb1 \
\cb3                     ligand \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 1\cf4 \cb1 \strokec4 \
\cb3                     \cf2 \strokec2 break\cf4 \cb1 \strokec4 \
\cb3             solList.\cf5 \strokec5 append\cf4 \strokec4 (ligand)\cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  solList\cb1 \
\
\
\
\cb3 ATOMIC_RADII \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 collections\cf4 \ulnone \strokec4 .\cf5 \ul \ulc5 \strokec5 defaultdict\cf4 \ulnone \strokec4 (
\f1\i \cf7 \strokec7 lambda
\f0\i0 \cf4 \strokec4 : \cf6 \strokec6 2.0\cf4 \strokec4 )\cb1 \
\cb3 ATOMIC_RADII.\cf5 \strokec5 update\cf4 \strokec4 (\cb1 \
\cb3     \{\cb1 \
\cb3         \cf10 \strokec10 "H"\cf4 \strokec4 : \cf6 \strokec6 1.200\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "HE"\cf4 \strokec4 : \cf6 \strokec6 1.400\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "C"\cf4 \strokec4 : \cf6 \strokec6 1.700\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "N"\cf4 \strokec4 : \cf6 \strokec6 1.550\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "O"\cf4 \strokec4 : \cf6 \strokec6 1.520\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "F"\cf4 \strokec4 : \cf6 \strokec6 1.470\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "NA"\cf4 \strokec4 : \cf6 \strokec6 2.270\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "MG"\cf4 \strokec4 : \cf6 \strokec6 1.730\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "P"\cf4 \strokec4 : \cf6 \strokec6 1.800\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "S"\cf4 \strokec4 : \cf6 \strokec6 1.800\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "CL"\cf4 \strokec4 : \cf6 \strokec6 1.750\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "K"\cf4 \strokec4 : \cf6 \strokec6 2.750\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "CA"\cf4 \strokec4 : \cf6 \strokec6 2.310\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "NI"\cf4 \strokec4 : \cf6 \strokec6 1.630\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "CU"\cf4 \strokec4 : \cf6 \strokec6 1.400\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "ZN"\cf4 \strokec4 : \cf6 \strokec6 1.390\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "SE"\cf4 \strokec4 : \cf6 \strokec6 1.900\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "BR"\cf4 \strokec4 : \cf6 \strokec6 1.850\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "CD"\cf4 \strokec4 : \cf6 \strokec6 1.580\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "I"\cf4 \strokec4 : \cf6 \strokec6 1.980\cf4 \strokec4 ,\cb1 \
\cb3         \cf10 \strokec10 "HG"\cf4 \strokec4 : \cf6 \strokec6 1.550\cf4 \strokec4 ,\cb1 \
\cb3     \}\cb1 \
\cb3 )\cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f1\i \cf7 \cb3 \strokec7 class
\f0\i0 \cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 ShrakeRupley\cf4 \ulnone \strokec4 :\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     \cf10 \strokec10 """Calculates SASAs using the Shrake-Rupley algorithm."""\cf4 \cb1 \strokec4 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf7 \strokec7 __init__\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 probe_radius
\f0\i0 \cf2 \strokec2 =\cf6 \strokec6 1.40\cf4 \strokec4 , 
\f1\i \cf9 \strokec9 n_points
\f0\i0 \cf2 \strokec2 =\cf6 \strokec6 960\cf4 \strokec4 , 
\f1\i \cf9 \strokec9 radii_dict
\f0\i0 \cf2 \strokec2 =\cf6 \strokec6 None\cf4 \strokec4 ):\cb1 \
\cb3         \cf10 \strokec10 """Initialize the class.\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb3 \strokec10         :param probe_radius: radius of the probe in A. Default is 1.40, roughly\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10             the radius of a water molecule.\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         :type probe_radius: float\cf4 \cb1 \strokec4 \
\
\cf10 \cb3 \strokec10         :param n_points: resolution of the surface of each atom. Default is 100.\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10             A higher number of points results in more precise measurements, but\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10             slows down the calculation.\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         :type n_points: int\cf4 \cb1 \strokec4 \
\
\cf10 \cb3 \strokec10         :param radii_dict: user-provided dictionary of atomic radii to use in\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10             the calculation. Values will replace/complement those in the\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10             default ATOMIC_RADII dictionary.\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         :type radii_dict: dict\cf4 \cb1 \strokec4 \
\
\cf10 \cb3 \strokec10         \cf2 \strokec2 >>> \cf10 \strokec10 sr = ShrakeRupley()\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         \cf2 \strokec2 >>> \cf10 \strokec10 sr = ShrakeRupley(n_points=960)\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         \cf2 \strokec2 >>> \cf10 \strokec10 sr = ShrakeRupley(radii_dict=\{"O": 3.1415\})\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         """\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3         \cf2 \strokec2 if\cf4 \strokec4  
\f1\i \cf9 \strokec9 probe_radius
\f0\i0 \cf4 \strokec4  \cf2 \strokec2 <=\cf4 \strokec4  \cf6 \strokec6 0.0\cf4 \strokec4 :\cb1 \
\cb3             \cf2 \strokec2 raise\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 ValueError\cf4 \ulnone \strokec4 (\cb1 \
\cb3                 
\f1\i \cf7 \strokec7 f
\f0\i0 \cf10 \strokec10 "Probe radius must be a positive number: \cf6 \strokec6 \{
\f1\i \cf9 \strokec9 probe_radius
\f0\i0 \cf6 \strokec6 \}\cf10 \strokec10  <= 0"\cf4 \cb1 \strokec4 \
\cb3             )\cb1 \
\cb3         
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .probe_radius \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 float\cf4 \ulnone \strokec4 (
\f1\i \cf9 \strokec9 probe_radius
\f0\i0 \cf4 \strokec4 )\cb1 \
\
\cb3         \cf2 \strokec2 if\cf4 \strokec4  
\f1\i \cf9 \strokec9 n_points
\f0\i0 \cf4 \strokec4  \cf2 \strokec2 <\cf4 \strokec4  \cf6 \strokec6 1\cf4 \strokec4 :\cb1 \
\cb3             \cf2 \strokec2 raise\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 ValueError\cf4 \ulnone \strokec4 (\cb1 \
\cb3                 
\f1\i \cf7 \strokec7 f
\f0\i0 \cf10 \strokec10 "Number of sphere points must be larger than 1: \cf6 \strokec6 \{
\f1\i \cf9 \strokec9 n_points
\f0\i0 \cf6 \strokec6 \}\cf10 \strokec10 "\cf4 \cb1 \strokec4 \
\cb3             )\cb1 \
\cb3         
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .n_points \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 n_points
\f0\i0 \cf4 \cb1 \strokec4 \
\
\cb3         \cf8 \strokec8 # Update radii list with user provided lists.\cf4 \cb1 \strokec4 \
\cb3         
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .radii_dict \cf2 \strokec2 =\cf4 \strokec4  ATOMIC_RADII.\cf5 \strokec5 copy\cf4 \strokec4 ()\cb1 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  
\f1\i \cf9 \strokec9 radii_dict
\f0\i0 \cf4 \strokec4  \cf2 \strokec2 is\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  \cf6 \strokec6 None\cf4 \strokec4 :\cb1 \
\cb3             
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .radii_dict.\cf5 \strokec5 update\cf4 \strokec4 (
\f1\i \cf9 \strokec9 radii_dict
\f0\i0 \cf4 \strokec4 )\cb1 \
\
\cb3         \cf8 \strokec8 # Pre-compute reference sphere\cf4 \cb1 \strokec4 \
\cb3         
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._sphere \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .\cf5 \strokec5 _compute_sphere\cf4 \strokec4 ()\cb1 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 _compute_sphere\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf10 \strokec10 """Return the 3D coordinates of n points on a sphere.\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb3 \strokec10         Uses the golden spiral algorithm to place points 'evenly' on the sphere\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         surface. We compute this once and then move the sphere to the centroid\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         of each atom as we compute the ASAs.\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         """\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3         n \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .n_points\cb1 \
\
\cb3         dl \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .pi \cf2 \strokec2 *\cf4 \strokec4  (\cf6 \strokec6 3\cf4 \strokec4  \cf2 \strokec2 -\cf4 \strokec4  \cf6 \strokec6 5\cf2 \strokec2 **\cf6 \strokec6 0.5\cf4 \strokec4 )\cb1 \
\cb3         dz \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 2.0\cf4 \strokec4  \cf2 \strokec2 /\cf4 \strokec4  n\cb1 \
\
\cb3         longitude \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 0\cf4 \cb1 \strokec4 \
\cb3         z \cf2 \strokec2 =\cf4 \strokec4  \cf6 \strokec6 1\cf4 \strokec4  \cf2 \strokec2 -\cf4 \strokec4  dz \cf2 \strokec2 /\cf4 \strokec4  \cf6 \strokec6 2\cf4 \cb1 \strokec4 \
\
\cb3         coords \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 zeros\cf4 \strokec4 ((n, \cf6 \strokec6 3\cf4 \strokec4 ), 
\f1\i \cf9 \strokec9 dtype
\f0\i0 \cf2 \strokec2 =\cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .float32)\cb1 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  k \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 range\cf4 \ulnone \strokec4 (n):\cb1 \
\cb3             r \cf2 \strokec2 =\cf4 \strokec4  (\cf6 \strokec6 1\cf4 \strokec4  \cf2 \strokec2 -\cf4 \strokec4  z \cf2 \strokec2 *\cf4 \strokec4  z) \cf2 \strokec2 **\cf4 \strokec4  \cf6 \strokec6 0.5\cf4 \cb1 \strokec4 \
\cb3             coords[k, \cf6 \strokec6 0\cf4 \strokec4 ] \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 math\cf4 \ulnone \strokec4 .\cf5 \strokec5 cos\cf4 \strokec4 (longitude) \cf2 \strokec2 *\cf4 \strokec4  r\cb1 \
\cb3             coords[k, \cf6 \strokec6 1\cf4 \strokec4 ] \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 math\cf4 \ulnone \strokec4 .\cf5 \strokec5 sin\cf4 \strokec4 (longitude) \cf2 \strokec2 *\cf4 \strokec4  r\cb1 \
\cb3             coords[k, \cf6 \strokec6 2\cf4 \strokec4 ] \cf2 \strokec2 =\cf4 \strokec4  z\cb1 \
\cb3             z \cf2 \strokec2 -=\cf4 \strokec4  dz\cb1 \
\cb3             longitude \cf2 \strokec2 +=\cf4 \strokec4  dl\cb1 \
\
\cb3         \cf2 \strokec2 return\cf4 \strokec4  coords\cb1 \
\
\cb3     
\f1\i \cf7 \strokec7 def
\f0\i0 \cf4 \strokec4  \cf5 \strokec5 compute\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 , 
\f1\i \cf9 \strokec9 atoms
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3         \cf10 \strokec10 """Calculate surface accessibility surface area for an entity.\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl420\partightenfactor0
\cf10 \cb3 \strokec10         The resulting atomic surface accessibility values are attached to the\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         .sasa attribute of each entity (or atom), depending on the level. For\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         example, if level="R", all residues will have a .sasa attribute. Atoms\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         will always be assigned a .sasa attribute with their individual values.\cf4 \cb1 \strokec4 \
\
\cf10 \cb3 \strokec10         :param entity: input entity.\cf4 \cb1 \strokec4 \
\cf10 \cb3 \strokec10         """\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3         \cf8 \strokec8 # Get atoms and coords\cf4 \cb1 \strokec4 \
\cb3         n_atoms \cf2 \strokec2 =\cf4 \strokec4  \cf5 \strokec5 len\cf4 \strokec4 (
\f1\i \cf9 \strokec9 atoms
\f0\i0 \cf4 \strokec4 )\cb1 \
\cb3         coords \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 ([a[\cf6 \strokec6 2\cf4 \strokec4 :\cf6 \strokec6 5\cf4 \strokec4 ] \cf2 \strokec2 for\cf4 \strokec4  a \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 atoms
\f0\i0 \cf4 \strokec4 ], 
\f1\i \cf9 \strokec9 dtype
\f0\i0 \cf2 \strokec2 =\cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .float64)\cb1 \
\
\cb3         \cf8 \strokec8 # Pre-compute atom neighbors using KDTree\cf4 \cb1 \strokec4 \
\cb3         kdt \cf2 \strokec2 =\cf4 \strokec4  KDTree(coords, \cf6 \strokec6 10\cf4 \strokec4 )\cb1 \
\
\cb3         \cf8 \strokec8 # Pre-compute radius * probe table\cf4 \cb1 \strokec4 \
\cb3         radii_dict \cf2 \strokec2 =\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .radii_dict\cb1 \
\cb3         radii \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 ([radii_dict[\cf5 \ul \ulc5 \strokec5 str\cf4 \ulnone \strokec4 (a[\cf6 \strokec6 5\cf4 \strokec4 ].split(\cf10 \strokec10 '.'\cf4 \strokec4 )[\cf6 \strokec6 0\cf4 \strokec4 ]).\cf5 \strokec5 upper\cf4 \strokec4 ()] \cf2 \strokec2 for\cf4 \strokec4  a \cf2 \strokec2 in\cf4 \strokec4  
\f1\i \cf9 \strokec9 atoms
\f0\i0 \cf4 \strokec4 ], 
\f1\i \cf9 \strokec9 dtype
\f0\i0 \cf2 \strokec2 =\cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .float64)\cb1 \
\cb3         radii \cf2 \strokec2 +=\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .probe_radius\cb1 \
\cb3         twice_maxradii \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .max(radii) \cf2 \strokec2 *\cf4 \strokec4  \cf6 \strokec6 2\cf4 \cb1 \strokec4 \
\
\cb3         \cf8 \strokec8 # Calculate ASAa\cf4 \cb1 \strokec4 \
\cb3         asa_array \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 zeros\cf4 \strokec4 ((n_atoms, \cf6 \strokec6 1\cf4 \strokec4 ), 
\f1\i \cf9 \strokec9 dtype
\f0\i0 \cf2 \strokec2 =\cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .int64)\cb1 \
\cb3         ptset \cf2 \strokec2 =\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 set\cf4 \ulnone \strokec4 (\cf5 \ul \ulc5 \strokec5 range\cf4 \ulnone \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .n_points))\cb1 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  i \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 range\cf4 \ulnone \strokec4 (n_atoms):\cb1 \
\cb3             r_i \cf2 \strokec2 =\cf4 \strokec4  radii[i]\cb1 \
\
\cb3             \cf8 \strokec8 # Move sphere to atom\cf4 \cb1 \strokec4 \
\cb3             s_on_i \cf2 \strokec2 =\cf4 \strokec4  (\cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .\cf5 \strokec5 array\cf4 \strokec4 (
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 ._sphere, 
\f1\i \cf9 \strokec9 copy
\f0\i0 \cf2 \strokec2 =\cf6 \strokec6 True\cf4 \strokec4 ) \cf2 \strokec2 *\cf4 \strokec4  r_i) \cf2 \strokec2 +\cf4 \strokec4  coords[i]\cb1 \
\cb3             available_set \cf2 \strokec2 =\cf4 \strokec4  ptset.\cf5 \strokec5 copy\cf4 \strokec4 ()\cb1 \
\
\cb3             \cf8 \strokec8 # KDtree for sphere points\cf4 \cb1 \strokec4 \
\cb3             kdt_sphere \cf2 \strokec2 =\cf4 \strokec4  KDTree(s_on_i, \cf6 \strokec6 10\cf4 \strokec4 )\cb1 \
\
\cb3             \cf8 \strokec8 # Iterate over neighbors of atom i\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  jj \cf2 \strokec2 in\cf4 \strokec4  kdt.search(coords[i], twice_maxradii):\cb1 \
\cb3                 j \cf2 \strokec2 =\cf4 \strokec4  jj.index\cb1 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  i \cf2 \strokec2 ==\cf4 \strokec4  j:\cb1 \
\cb3                     \cf2 \strokec2 continue\cf4 \cb1 \strokec4 \
\
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  jj.radius \cf2 \strokec2 <\cf4 \strokec4  (r_i \cf2 \strokec2 +\cf4 \strokec4  radii[j]):\cb1 \
\cb3                     \cf8 \strokec8 # Remove overlapping points on sphere from available set\cf4 \cb1 \strokec4 \
\cb3                     available_set \cf2 \strokec2 -=\cf4 \strokec4  \{\cb1 \
\cb3                         pt.index \cf2 \strokec2 for\cf4 \strokec4  pt \cf2 \strokec2 in\cf4 \strokec4  kdt_sphere.search(coords[j], radii[j])\cb1 \
\cb3                     \}\cb1 \
\
\cb3             asa_array[i] \cf2 \strokec2 =\cf4 \strokec4  \cf5 \strokec5 len\cf4 \strokec4 (available_set)  \cf8 \strokec8 # update counts\cf4 \cb1 \strokec4 \
\
\cb3         \cf8 \strokec8 # Convert accessible point count to surface area in A**2\cf4 \cb1 \strokec4 \
\cb3         f \cf2 \strokec2 =\cf4 \strokec4  radii \cf2 \strokec2 *\cf4 \strokec4  radii \cf2 \strokec2 *\cf4 \strokec4  (\cf6 \strokec6 4\cf4 \strokec4  \cf2 \strokec2 *\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .pi \cf2 \strokec2 /\cf4 \strokec4  
\f1\i \cf9 \strokec9 self
\f0\i0 \cf4 \strokec4 .n_points)\cb1 \
\cb3         asa_array \cf2 \strokec2 =\cf4 \strokec4  asa_array \cf2 \strokec2 *\cf4 \strokec4  f[:, \cf5 \ul \ulc5 \strokec5 np\cf4 \ulnone \strokec4 .newaxis]\cb1 \
\
\cb3         \cf8 \strokec8 # Set atom .sasa\cf4 \cb1 \strokec4 \
\cb3         sasa \cf2 \strokec2 =\cf4 \strokec4  []\cb1 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  i, atom \cf2 \strokec2 in\cf4 \strokec4  \cf5 \ul \ulc5 \strokec5 enumerate\cf4 \ulnone \strokec4 (
\f1\i \cf9 \strokec9 atoms
\f0\i0 \cf4 \strokec4 ):\cb1 \
\cb3             sasa.\cf5 \strokec5 append\cf4 \strokec4 (asa_array[i, \cf6 \strokec6 0\cf4 \strokec4 ])\cb1 \
\cb3         \cf2 \strokec2 return\cf4 \strokec4  sasa\cb1 \
\
\
\
\
\
\
\
\
}